module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
); //

    // Use FSM from Fsm_serial

    // New: Datapath to latch input bits.
// declare the two states 
    parameter RESET=3'b000, START=3'b001, WAIT=3'b010, ERROR=3'b100, FINISH=3'b011;
    parameter  TCQ = 1;
    
    reg [2:0] state, next_state;
    
    
    // counter
    reg reset_count;
    
    reg [8:0]cnt_8;
    reg en_cnt_8;
    reg end_cnt_8;
    reg full_cnt_8;
    reg reset_counter;
    reg lagger_cnt_8; // to record if the counter now is lagger than 8
    
    reg done_reg;
    
    reg [7:0] data_input_reg;

    //  count 8 clock cycle
    always@(posedge clk)
    begin
        //  synchronous reset
        if ( reset_counter==1 )       
            cnt_8 <=  #TCQ 9'd0;
        else if(end_cnt_8)     //2nd set
            cnt_8 <= #TCQ 9'd7;
        else if (en_cnt_8)
            cnt_8 <=  #TCQ cnt_8 + 1'd1;
        else
            cnt_8 <= #TCQ  9'd0;   
    end


    //end_cnt_8 flag circuit
    always@(posedge clk)
    begin
        //  synchronous reset
        if ( reset_counter==1 )  
        begin
            end_cnt_8 <= #TCQ 1'b0;
            lagger_cnt_8 <= #TCQ 1'b0;
        end
        else if (cnt_8 == (9'd7))
            begin
                end_cnt_8 <= #TCQ   1'b1;
                lagger_cnt_8 <= #TCQ  1'b0;
            end
        else if (cnt_8 >= (9'd7))
            begin
                end_cnt_8 <= #TCQ  1'b0;
                lagger_cnt_8 <= #TCQ  1'b1;
            end
                // different than lemmings, the end_cnt_8 only have one time for a high level.
                // in the WATI state, just judge is this the time that have 8 clock cycle, otherwise, it is wrong transmission
                
       else
            begin
                lagger_cnt_8 <= #TCQ  1'b0;
                end_cnt_8 <= #TCQ 1'b0;
            end
    end
    
         
         
        always @(posedge clk) 
        begin
        // State flip-flops with synchronous reset
         if (reset==1)
                    begin
                        state <= #TCQ  RESET;
                        done_reg <= #TCQ  0;
                        reset_counter <= #TCQ 1;
                        en_cnt_8 <= #TCQ 0;
                        reset_count <= 1;
                        data_input_reg <= 8'b0;
                    end
        else
            begin
                case(state)
                    RESET:   
                        begin
                            if (in==0)   // the start indication
                                begin
                                     state <= #TCQ  WAIT;
                                     done_reg <= #TCQ  0;
                                     data_input_reg <=  8'b0;
                                     reset_counter <=#TCQ   0;   // start the counter
                                     en_cnt_8 <= #TCQ 1;       // start the counter
                                
                                end                            
                            else
                                begin
                                     state <= #TCQ RESET;
                                     done_reg <= #TCQ 0;
                                     reset_counter <= #TCQ 0;   // disable the reset
                                     en_cnt_8 <= #TCQ 0;   // disable the counter
                                end

                        end
                WAIT:
                      begin
                            if ((in==1)&&(end_cnt_8==1))   // the start indication
                                begin
                                     state <= #TCQ FINISH;     // the correct version
                                     done_reg <= #TCQ 1;
                                     reset_counter <= #TCQ 1;   // reset the counter
                                     en_cnt_8 <= #TCQ 0;        // start the counter
                                
                                end                            
                            else if (lagger_cnt_8==1)   // no matter the in is 0 or 1, the error happens, goes to the reset
                                begin
                                     state <= #TCQ ERROR;
                                     done_reg <= #TCQ 0;        // the wrong version
                                     reset_counter <= #TCQ 1;   // disable the counter
                                     en_cnt_8 <= #TCQ  0;   // disable the counter
                                end
                            else
                                begin
                                     state <= #TCQ  WAIT;
                                     // start to collect the data in
                                     data_input_reg <= {in,{data_input_reg[7:1]}};
                                    
                                     done_reg <=#TCQ  0;
                                     reset_counter <= #TCQ 0;   // start the counter
                                     en_cnt_8 <= #TCQ 1;        // start the counter
                                end    
                        end  
                
                FINISH:
                      begin
                            if (in==0)   // the start indication
                                begin
                                     state <= #TCQ WAIT;
                                     done_reg <=#TCQ  0;
                                     reset_counter <= #TCQ 0;   // start the counter
                                     en_cnt_8 <= #TCQ 1;       // start the counter
                                
                                end                            
                            else
                                begin
                                     state <= #TCQ RESET;
                                     done_reg <=#TCQ 0;
                                     reset_counter <=#TCQ  1;   // disable the counter
                                     en_cnt_8 <= #TCQ 0;   // disable the counter
                                end

                        end
                 ERROR:
                      begin
                          if (in==0)   // the start indication
                                begin
                                     state <= #TCQ RESET;
                                     done_reg <= #TCQ 0;
                                     reset_counter <= #TCQ 0;   // start the counter
                                     en_cnt_8 <= #TCQ 1;       // start the counter
                                
                                end                            
                            else
                                begin
                                     state <= #TCQ RESET;
                                     done_reg <= #TCQ 0;
                                     reset_counter <= #TCQ  1;   // disable the counter
                                     en_cnt_8 <= #TCQ 0;   // disable the counter
                                end

                        end    
                   default:
                            begin
                                    state <= RESET;
                       
                       
                            end
                       
                        
                          
                 endcase
                
            end 

     end
    
    
    assign done = done_reg;
    assign out_byte = data_input_reg;
    
    
    
endmodule
