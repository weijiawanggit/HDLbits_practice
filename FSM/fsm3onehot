module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000;

    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[0] = state[0]&(~in) | state[2]&(~in);   // that table contains A
    assign next_state[1] = state[0]&(in)  |  state[1]&(in) | state[3]&(in);
    assign next_state[2] = state[1]&(~in) | state[3]&(~in);
    assign next_state[3] = state[2]&(in);

    // Output logic: 
    assign out = (state[3]) ? 1:0;
    
    
    /*
            always@(*) begin  // This is a combinational circuit
            case(state)
                
               4'b1100:
					out = 1;
               4'b1110:
					out = 1;
               4'b1111:
					out = 1;
               4'b1001:
					out = 1;
               4'b1001:
					out = 1;
               4'b11xx:
					out = 1;
               4'b1000:
					out = 1;
               4'b0xxx:
					out = 0;
               4'b0100:
					out = 0;
               4'b0010:
					out = 0;
               4'b0001:
					out = 0;
               4'b01xx:
					out = 0;
                
                
                //4'b01xx:::
				//	out = 0;
                //D:
				//	out = 1;
          
                default:
                    out = 0;
            endcase
        end
    */
    

endmodule
